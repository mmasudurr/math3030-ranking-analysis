# -*- coding: utf-8 -*-
"""tournament_sim(w Colley).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TpVUqLD4z9r5wwWcXRfw8YaW-09vP8eh
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- 1. SETUP ---
np.random.seed(42)
n_bots = 10
bot_names = [f"Bot_{i}" for i in range(n_bots)]
# True skills (10-90)
true_skills = np.sort(np.random.randint(10, 90, n_bots))

# DATA STORAGE
game_history = []

# --- 2. RUN TOURNAMENT (More Games!) ---
# We will run 10 Rounds (everyone plays everyone 10 times) to reduce noise
print(f"--- Simulating Tournament (10 Rounds) ---")

for round in range(10):
    for i in range(n_bots):
        for j in range(n_bots):
            if i == j: continue

            # --- THE FIX IS HERE ---
            diff = true_skills[i] - true_skills[j]
            # Changed divisor from 400 to 40 to make skill matter more!
            prob_a = 1 / (1 + 10**(-diff / 40.0))

            if np.random.rand() < prob_a:
                winner = i
            else:
                winner = j

            game_history.append((i, j, winner))

# --- 3. METHOD A: ELO RATING ---
elo_ratings = np.ones(n_bots) * 1200
K = 32

for p1, p2, winner in game_history:
    actual_score = 1 if winner == p1 else 0

    # We keep 400 here because ELO output should still look like standard ELO (1200 range)
    # But the INPUT game data is now cleaner.
    expected_p1 = 1 / (1 + 10**((elo_ratings[p2] - elo_ratings[p1]) / 400))

    elo_ratings[p1] += K * (actual_score - expected_p1)
    elo_ratings[p2] += K * ((1 - actual_score) - (1 - expected_p1))

# --- 4. METHOD B: COLLEY MATRIX ---
colley_matrix = np.zeros((n_bots, n_bots))
b_vector = np.zeros(n_bots)
wins = np.zeros(n_bots)
losses = np.zeros(n_bots)

for p1, p2, winner in game_history:
    if winner == p1:
        wins[p1] += 1
        losses[p2] += 1
    else:
        wins[p2] += 1
        losses[p1] += 1

    colley_matrix[p1, p2] -= 1

for i in range(n_bots):
    total_games = wins[i] + losses[i]
    colley_matrix[i, i] = 2 + total_games
    b_vector[i] = 1 + (wins[i] - losses[i]) / 2

colley_ratings = np.linalg.solve(colley_matrix, b_vector)

# --- 5. COMPARE RESULTS ---
print("\n--- FINAL COMPARISON ---")
df = pd.DataFrame({
    'Bot': bot_names,
    'True_Skill': true_skills,
    'Elo_Rating': np.round(elo_ratings, 0),
    'Colley_Score': np.round(colley_ratings, 3)
})

# Sort by True Skill
df = df.sort_values(by='True_Skill', ascending=False)
print(df.to_string(index=False))

# Calculate Accuracy
elo_corr = df['True_Skill'].corr(df['Elo_Rating'])
colley_corr = df['True_Skill'].corr(df['Colley_Score'])

print(f"\nCorrelation with True Skill (Target > 0.9):")
print(f"Elo Method:    {elo_corr:.4f}")
print(f"Colley Method: {colley_corr:.4f}")


# --- 6. GENERATE COLLEY VISUALIZATION ---
print("\nGenerating Colley analysis graph...")

plt.figure(figsize=(10, 6))

# 1. Plot the Bots as dots
# X-axis = True Skill, Y-axis = Colley Score
plt.scatter(df['True_Skill'], df['Colley_Score'], color='blue', s=100, label='Bots')

# 2. Draw a red "Trend Line" to show the correlation
# This calculates the "Line of Best Fit"
z = np.polyfit(df['True_Skill'], df['Colley_Score'], 1)
p = np.poly1d(z)
plt.plot(df['True_Skill'], p(df['True_Skill']), "r--", linewidth=2, label=f'Trend Line (Corr: {colley_corr:.3f})')

# 3. Labeling the specific bots
for i in range(len(df)):
    plt.text(df.iloc[i]['True_Skill'] + 1, df.iloc[i]['Colley_Score'],
             df.iloc[i]['Bot'], fontsize=9)

plt.title("Method B: Colley Matrix Accuracy Analysis")
plt.xlabel("True Hidden Skill (0-100)")
plt.ylabel("Calculated Colley Rating")
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.savefig("colley_analysis.png")
print("Graph saved as 'colley_analysis.png'")
plt.show()

